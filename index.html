<!DOCTYPE html>
<html lang="en">
  <head>
    <title>lol</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        font-family: Monospace;
        background-color: #000;
        color: #fff;
        margin: 0px;
        overflow: hidden;
      }
      #editTexture {
        position: absolute;
        width: 50%;
        height: 100%;
        right: 0;
        top: 0;
        background-color: rgb(0.2,0.2,0.2);
      }
      #info {
        color: #fff;
        padding: 10px;
        text-align: center;
        background-color: rgba(255,255,255,0.3);
      }
      #cropCanvas {
        overflow: hidden;
      }
      #canvasContainer {
        position: relative;
      }
    </style>
  </head>

  <body>

    <div id="editTexture">
      <div id="info">
        <ul id="models">
        </ul>
      </div>
      <div id="cropCanvas">
        <div id="canvasContainer"></div>
      </div>
    </div>

    <script src="http://d3lp1msu2r81bx.cloudfront.net/kjs/js/lib/kinetic-v5.0.2.min.js"></script>
    <script src="js/three.min.js"></script>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>

    <script src="js/loaders/DDSLoader.js"></script>
    <script src="js/loaders/OBJLoader.js"></script>

    <script src="js/Detector.js"></script>
    <!-- <script src="js/libs/stats.min.js"></script> -->

    <script>

      var modelInfo = {
        shirt: {
          file: 'models/testshirt.obj',
          objYOffset: 0,
          objScale: [0.1, 0.1, 0.1],
          objRotate: [0, 0, 0],

          //todo: relative to size of window
          canvasAspect: 1,
          topMargin: 0.38,
          bottomMargin: 0.1,
          leftMargin: 0,
          rightMargin: 0.46
        },
        mug: {
          file: 'models/mug.obj',
          objYOffset: -7,
          objScale: [0.3, 0.3, 0.3],
          objRotate: [0, 0, 0],

          canvasAspect: 3,
          topMargin: 0,
          bottomMargin: 0,
          leftMargin: 0,
          rightMargin: 0
        },
        iphone: {
          file: 'models/iphone.obj',
          objYOffset: 0,
          objScale: [10, 10, 10],
          objRotate: [Math.PI/2, 0, Math.PI],

          canvasAspect: 1,
          topMargin: 0.1,
          bottomMargin: 0.1,
          leftMargin: 0.5,
          rightMargin: 0
        }
      };


      var container, stats, canvas;
      var camera, scene, renderer;

      var mouseX = 0, mouseY = 0;
      var windowHalfX = window.innerWidth / 2;
      var windowHalfY = window.innerHeight / 2;

      init();
      animate();

      function init() {
        // create dom elems
        canvas = document.createElement('canvas');

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
        camera.position.z = 100;

        // scene
        scene = new THREE.Scene();

        var ambient = new THREE.AmbientLight( 0x444444 );
        scene.add( ambient );

        directionalLight = new THREE.DirectionalLight( 0xffeedd );
        directionalLight.position.set( 0, 0, 1 ).normalize();
        scene.add( directionalLight );

        // model

        THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader() );

        models = new THREE.Object3D();
        scene.add(models);

        var selectModel = function(name) {
          // visibility of 3d model
          for (var i = 0; i < models.children.length; i++) {
            models.children[i].visible = models.children[i].name == name;
          }


          // canvas crop

          // find model info
          var model = modelInfo[name];

          // resize canvas
          // find element sizes
          var maxW = $('#editTexture').width();
          var maxH = $('#editTexture').height();

          // fit the aspect ratio to the element size
          var aspectRatio = model.canvasAspect;
          console.log(aspectRatio);
          var croppedAspectRatio = (1 - model.leftMargin - model.rightMargin)
            / (1 - model.topMargin - model.bottomMargin) * aspectRatio;
          console.log('aa');
            console.log(croppedAspectRatio);
          var width = maxW;
          var height = maxH;
          if (maxH * croppedAspectRatio > maxW) {
            width = maxW;
            height = maxW * 1/croppedAspectRatio;
          } else {
            width = maxH * croppedAspectRatio;
            height = maxH;
          }

          // (1-margins) = width/canvasWidth
          // TODO: use power of 2 canvas width/height and scale to fit
          var canvasWidth = width/(1 - model.leftMargin - model.rightMargin);
          var canvasHeight = height/(1 - model.topMargin - model.bottomMargin);

          console.log(canvasWidth);
          console.log(canvasHeight);
          stage.setWidth(canvasWidth);
          stage.setHeight(canvasHeight);
          bgRect.setWidth(canvasWidth);
          bgRect.setHeight(canvasHeight);

          // reposition cropping divs
          // TODO: onResize
          $('#canvasContainer').css({
              top: -canvasHeight * model.topMargin,
              left: -canvasWidth * model.leftMargin
              });

          // resize cropping div
          $('#cropCanvas').height(height);
          $('#cropCanvas').width(width);

          // reposition overlay image , todo: if its outside
          console.log(dragImg.position());
          dragImg.position({
              x: canvasWidth * model.leftMargin,
              y: canvasHeight * model.topMargin});
          console.log(dragImg.position());
          layer.draw();

          // needs to happen when the canvas actually updates
          texture.needsUpdate = true;
        }


        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth/2, window.innerHeight );
        container.appendChild( renderer.domElement );

        container.addEventListener( 'mousedown', onContainerMouseDown, false );
        container.addEventListener( 'mouseup', onContainerMouseUp, false );
        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        window.addEventListener( 'resize', onWindowResize, false );


        // create kinetic canvas
        var stage = new Kinetic.Stage({
          container: "canvasContainer",
          width: 1000,
          height: 1000
        });

        function drawImage(imageObj) { 
          layer = new Kinetic.Layer();
          texture = new THREE.Texture(layer.getCanvas()._canvas);
          // todo: bg rect should be written in the shader so that our
          // canvas is transp
          bgRect = new Kinetic.Rect({
              x: 0,
              y: 0,
              width: 1000, //full width
              height: 1000, //full height
              fill: 'white', //background color
              });
          layer.add(bgRect);

          // draggable image
          iWidth = imageObj.width;
          iHeight = imageObj.height;
          dragImg = new Kinetic.Image({
            image: imageObj,
            x: 200,
            y: 330,
            width: 276,
            height: 80,
            draggable: true
          });

          // add cursor styling
          dragImg.on('mouseover', function() {
            document.body.style.cursor = 'pointer';
          });
          dragImg.on('mouseout', function() {
            document.body.style.cursor = 'default';
            texture.needsUpdate = true;
          });

          dragImg.on('dragmove', function() {
              texture.needsUpdate = true;
          });

          layer.add(dragImg);

          texture.needsUpdate = true;

          stage.add(layer);
          var manager = new THREE.LoadingManager();
          var loader = new THREE.OBJLoader(manager);
          // add models
          Object.keys(modelInfo).forEach(function(modelName) {
              var model = modelInfo[modelName];
              loader.load(model.file, function ( object ) {
                object.traverse( function ( child ) {
                  if ( child instanceof THREE.Mesh ) {
                    child.material.map = texture;
                  }
                } );
                object.position.y = model.objYOffset;
                object.scale.set(model.objScale[0],
                  model.objScale[1],
                  model.objScale[2]);
                object.rotation.x = model.objRotate[0];
                object.rotation.y = model.objRotate[1];
                object.rotation.z = model.objRotate[2];
                object.visible = false;
                object.name = modelName;
                models.add(object);

                $('ul#models').append(
                  $('<li>'+modelName+'</li>').click(function() {
                    selectModel(modelName)}));
              } );

          });
        }

        var imageObj = new Image();
        imageObj.onload = function() {
          drawImage(this);
        };
        // todo: user upload image thing
        imageObj.src = 'tex/ooshirts-logo.png';

      }

      function onWindowResize() {

        windowHalfX = window.innerWidth / 4;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth/2 / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth/2, window.innerHeight );

      }

      clicked = false;
      mouseDownX = 0;
      mouseDownY = 0;
      function onContainerMouseDown( event ) {
        clicked = true;
        mouseDownX = event.clientX;
        mouseDownY = event.clientY;
      }
      function onContainerMouseUp( event ) {
        clicked = false;
      }
      function onDocumentMouseMove( event ) {
        if (clicked) {
          mouseX += (event.clientX - mouseDownX);
          mouseY += (event.clientY - mouseDownY);
          mouseDownX = event.clientX;
          mouseDownY = event.clientY;
        }
      }

      //

      function animate() {

        requestAnimationFrame( animate );
        render();

      }

      function render() {

        // camera.position.x += ( mouseX - camera.position.x ) * .05;
        // camera.position.y += ( - mouseY - camera.position.y ) * .05;
        var radius = 40;
        var freqX = 0.01;
        var freqY = freqX/2;
        camera.position.x = radius*Math.sin(-mouseX*freqX);
        camera.position.z = radius*Math.cos(-mouseX*freqX);// + radius*Math.cos(mouseY*freqY);
        camera.position.y = radius*Math.sin(mouseY*freqY);

        camera.lookAt( scene.position );

        renderer.render( scene, camera );

      }

    </script>

  </body>
</html>
